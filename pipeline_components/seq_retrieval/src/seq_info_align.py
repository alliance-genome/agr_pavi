#!/usr/bin/env python3
"""
Main module serving the CLI for PAVI sequence info align component.

Collects and merges sequence info generated by the sequence retrieval component
 + adds relative alignment positions for all variants using alignment results.
"""
from Bio import AlignIO
from Bio.SeqRecord import SeqRecord
from Bio.Align import MultipleSeqAlignment
import click
from enum import Enum
import json
import jsonpickle  # type: ignore
import logging
from os import path, access, R_OK
from typing import Any, List, Optional

from log_mgmt import set_log_level, get_logger
from variant import AlignmentEmbeddedVariant, AlignmentEmbeddedVariantsList
from seq_info import EnumValueHandler, SeqInfo

logger = get_logger(name=__name__)


def process_sequence_info_files_param(ctx: click.Context, param: click.Parameter, value: str) -> List[str]:  # noqa: U100
    """
    Parse the value of click input parameter seq_info_files and validate its content.

    Value is expected to be a space-separated list of files containing json-formatted sequence info.

    Returns:
        List of string representing the files containing sequence info

    Raises:
        click.BadParameter: If value could not be parsed as space-separated list or the filepaths in it are invalid.
    """
    sequence_info_files = value.split(' ')

    # Validate each of the sequence info files exists and is a readable file
    for sequence_info_file in sequence_info_files:
        if not path.exists(sequence_info_file):
            raise click.BadParameter(f"Sequence info file '{sequence_info_file}' does not exist.")
        if not path.isfile(sequence_info_file):
            raise click.BadParameter(f"Sequence info file '{sequence_info_file}' is not a regular file.")
        if not access(sequence_info_file, R_OK):
            raise click.BadParameter(f"Sequence info file '{sequence_info_file}' is not readable.")

    return sequence_info_files


def process_alignment_result_file_param(ctx: click.Context, param: click.Parameter, value: str) -> str:  # noqa: U100
    """
    Parse the value of click input parameter alignment_result_file and validate its content.

    Value is expected to be a space-separated list of files containing json-formatted sequence info.

    Returns:
        List of string representing the files containing sequence info

    Raises:
        click.BadParameter: If the provided value is not a valid readable file path.
    """

    # Validate the alignment result file exists and is a readable file
    if not path.exists(value):
        raise click.BadParameter(f"Sequence info file '{value}' does not exist.")
    if not path.isfile(value):
        raise click.BadParameter(f"Sequence info file '{value}' is not a regular file.")
    if not access(value, R_OK):
        raise click.BadParameter(f"Sequence info file '{value}' is not readable.")

    return value


@click.command(context_settings={'show_default': True})
@click.option("--sequence-info-files", type=click.UNPROCESSED, required=True, callback=process_sequence_info_files_param,
              help="Space separated list of sequence info files to read.")
@click.option("--alignment-result-file", type=click.UNPROCESSED, required=True, callback=process_alignment_result_file_param,
              help="Path to alignment output file.")
@click.option("--debug", is_flag=True,
              help="""Flag to enable debug printing.""")
def main(alignment_result_file: str, sequence_info_files: List[str], debug: bool) -> None:
    if debug:
        set_log_level(logging.DEBUG)
    else:
        set_log_level(logging.INFO)

    logger.debug(f"sequence_info_files: {sequence_info_files}")
    logger.debug(f"alignment output file: {alignment_result_file}")

    alt_sequence_info_dict: dict[str, SeqInfo] = {}

    # * Read each of the sequence_info_files (JSON) and merge into a single dict
    for file in sequence_info_files:
        try:
            with open(file, 'r') as f:
                sequence_info_json_dict: dict[str, Any] = json.load(f)
                sequence_info_dict: dict[str, SeqInfo] = {}
                for key, value in sequence_info_json_dict.items():
                    sequence_info_dict[key] = SeqInfo.from_dict(value)
                alt_sequence_info_dict.update(sequence_info_dict)
        except Exception as e:
            logger.error(f"Failed to read sequence info file '{file}': {e}")
            exit(1)

    # * Read alignment_result_file
    alignment: MultipleSeqAlignment
    try:
        alignment = next(AlignIO.parse(alignment_result_file, "clustal"))
    except Exception as e:
        logger.error(f"Failed to read alignment result file '{alignment_result_file}': {e}")
        exit(1)

    if not isinstance(alignment, MultipleSeqAlignment):
        logger.error(f"Alignment result file '{alignment_result_file}' does not contain a multiple sequence alignment.")
        exit(1)

    # * Loop over each record in the alignment_result_file and update the sequence info dict with relative alignment positions
    aligned_seq_info_dict: dict[str, SeqInfo] = {}
    for record in alignment:
        if not isinstance(record, SeqRecord):
            logger.error(f"Error while parsing record of alignment result file '{alignment_result_file}'.")
            exit(1)
        if record.seq is None:
            logger.error(f"Error while reading record sequence for alignment record '{record.id}'.")
            exit(1)

        aligned_variants: Optional[AlignmentEmbeddedVariantsList] = None

        if record.id in alt_sequence_info_dict:
            if hasattr(alt_sequence_info_dict[record.id], 'embedded_variants'):
                embedded_variants = alt_sequence_info_dict[record.id].embedded_variants
                if isinstance(embedded_variants, AlignmentEmbeddedVariantsList):
                    aligned_variants = embedded_variants
                else:
                    aligned_variants = AlignmentEmbeddedVariantsList()
                    if embedded_variants:
                        for variant in embedded_variants:
                            aligned_variants.append(AlignmentEmbeddedVariant(variant, record))

            aligned_seq_info_dict[record.id] = SeqInfo(embedded_variants=aligned_variants)

    jsonpickle.set_encoder_options("simplejson", sort_maps=True)
    jsonpickle.register(Enum, EnumValueHandler, base=True)
    with open('seq_info.json', 'w') as f:
        f.write(jsonpickle.encode(aligned_seq_info_dict, make_refs=False, unpicklable=False))


if __name__ == '__main__':
    main()
