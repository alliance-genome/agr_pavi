#!/usr/bin/env python3
"""
Main module serving the CLI for PAVI sequence info align component.

Collects and merges sequence info generated by the sequence retrieval component
 + adds relative alignment positions for all variants using alignment results.
"""
from Bio import AlignIO
from Bio.SeqRecord import SeqRecord
from Bio.Align import MultipleSeqAlignment
import click
import json
import jsonpickle  # type: ignore
import logging
from os import path, access, R_OK
from typing import Any, List

from log_mgmt import set_log_level, get_logger

logger = get_logger(name=__name__)


def process_sequence_info_files_param(ctx: click.Context, param: click.Parameter, value: str) -> List[str]:  # noqa: U100
    """
    Parse the value of click input parameter seq_info_files and validate its content.

    Value is expected to be a space-separated list of files containing json-formatted sequence info.

    Returns:
        List of string representing the files containing sequence info

    Raises:
        click.BadParameter: If value could not be parsed as space-separated list or the filepaths in it are invalid.
    """
    sequence_info_files = value.split(' ')

    # Validate each of the sequence info files exists and is a readable file
    for sequence_info_file in sequence_info_files:
        if not path.exists(sequence_info_file):
            raise click.BadParameter(f"Sequence info file '{sequence_info_file}' does not exist.")
        if not path.isfile(sequence_info_file):
            raise click.BadParameter(f"Sequence info file '{sequence_info_file}' is not a regular file.")
        if not access(sequence_info_file, R_OK):
            raise click.BadParameter(f"Sequence info file '{sequence_info_file}' is not readable.")

    return sequence_info_files


def process_alignment_result_file_param(ctx: click.Context, param: click.Parameter, value: str) -> str:  # noqa: U100
    """
    Parse the value of click input parameter alignment_result_file and validate its content.

    Value is expected to be a space-separated list of files containing json-formatted sequence info.

    Returns:
        List of string representing the files containing sequence info

    Raises:
        click.BadParameter: If the provided value is not a valid readable file path.
    """

    # Validate the alignment result file exists and is a readable file
    if not path.exists(value):
        raise click.BadParameter(f"Sequence info file '{value}' does not exist.")
    if not path.isfile(value):
        raise click.BadParameter(f"Sequence info file '{value}' is not a regular file.")
    if not access(value, R_OK):
        raise click.BadParameter(f"Sequence info file '{value}' is not readable.")

    return value


def seq_to_alignment_position(seqRecord: SeqRecord, pos: int) -> int:
    """
    Convert a sequence position to its corresponding alignment position.

    Args:
        seq: Alignment sequence record to generate relative position for.
        pos: Sequence position to be converted.

    Returns:
        Alignment position of the sequence record.
    """
    if seqRecord.seq is None:
        raise ValueError(f"Sequence record '{seqRecord.id}' has no sequence.")

    tmp_alignment_pos = pos
    gap_count = seqRecord.seq[:tmp_alignment_pos].count("-")
    while tmp_alignment_pos - gap_count < pos:
        tmp_alignment_pos = pos + gap_count
        gap_count = seqRecord.seq[:tmp_alignment_pos].count("-")

    return pos + gap_count


@click.command(context_settings={'show_default': True})
@click.option("--sequence-info-files", type=click.UNPROCESSED, required=True, callback=process_sequence_info_files_param,
              help="Space separated list of sequence info files to read.")
@click.option("--alignment-result-file", type=click.UNPROCESSED, required=True, callback=process_alignment_result_file_param,
              help="Path to alignment output file.")
@click.option("--debug", is_flag=True,
              help="""Flag to enable debug printing.""")
def main(alignment_result_file: str, sequence_info_files: List[str], debug: bool) -> None:
    if debug:
        set_log_level(logging.DEBUG)
    else:
        set_log_level(logging.INFO)

    logger.debug(f"sequence_info_files: {sequence_info_files}")
    logger.debug(f"alignment output file: {alignment_result_file}")

    all_sequence_info: dict[str, Any] = {}
    # * Read each of the sequence_info_files (JSON) and merge into a single dict
    for file in sequence_info_files:
        try:
            with open(file, 'r') as f:
                sequence_info: dict[str, Any] = json.load(f)
                all_sequence_info.update(sequence_info)
        except Exception as e:
            logger.error(f"Failed to read sequence info file '{file}': {e}")
            exit(1)

    # * Read alignment_result_file
    alignment: MultipleSeqAlignment
    try:
        alignment = next(AlignIO.parse(alignment_result_file, "clustal"))
    except Exception as e:
        logger.error(f"Failed to read alignment result file '{alignment_result_file}': {e}")
        exit(1)

    if not isinstance(alignment, MultipleSeqAlignment):
        logger.error(f"Alignment result file '{alignment_result_file}' does not contain a multiple sequence alignment.")
        exit(1)

    # * Loop over each record in the alignment_result_file and update the sequence info dict with relative alignment positions
    #   rel alignment pos = rel_(start|end) + "-" count from start till variant start|end
    for record in alignment:
        if not isinstance(record, SeqRecord):
            logger.error(f"Error while parsing record of alignment result file '{alignment_result_file}'.")
            exit(1)
        if record.seq is None:
            logger.error(f"Error while reading record sequence for alignment record '{record.id}'.")
            exit(1)

        if record.id in all_sequence_info and 'embedded_variants' in all_sequence_info[record.id]:
            for variant in all_sequence_info[record.id]["embedded_variants"]:
                variant["alignment_rel_start"] = seq_to_alignment_position(record, variant["rel_start"])
                variant["alignment_rel_end"] = seq_to_alignment_position(record, variant["rel_end"])

    jsonpickle.set_encoder_options("simplejson", sort_maps=True)
    with open('seq_info.json', 'w') as f:
        f.write(jsonpickle.encode(all_sequence_info, unpicklable=False))


if __name__ == '__main__':
    main()
